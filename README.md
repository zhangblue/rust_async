# Rust 异步编程 (Async Rust)

Rust的异步编程主要处理并发性。底层可能利用并行性(取决于硬件、操作系统和异步运行时)。

异步运行时负责协调和管理并发任务。

# 入门回顾

- [Futures和异步语法](./hello_async)
- [使用 Async 实现并发](./async_concurrency)
- [Stream](./stream)
- [Traits for Async (异步主要的 Traits)](./traits_for_async)
- [综合来看：Future、任务和线程](./futures_tasks_threads)

## 核心概念

并行性(`Parallelism`)：多个执行单元同时处理不同任务。多核处理器可以实现并发与并行

并发性(`Concurrency`)：一个执行单元处理多个任务，通过任务切换来实现。单核处理器只能实现并发

串行性(`Serial Work`)：任务必须按特定顺序一个接一个完成

阻塞操作(`Blocking Operations`)：阻止程序继续执行直到操作完成

非阻塞操作(`Non-blocking Operations`)：允许程序在等待时执行其他任务

## 操作类型

- CPU密集型(CPU-bound)：受处理能力限制（比如视频导出）
- IO密集型(IO-bound)：受输入/输出速度限制（如文件下载）

## 系统线程

由操作系统管理，抢占式多任务 (preemptively multi-tasked)

- OS Scheduler (调度器) 可以随时中断一个线程
- 调度器本身也是相对"重量级"的
    - 需要保存当前线程的状态，加载下一个线程的状态，然后恢复执行
- 对任务的调度只有有限的控制权

## 异步模型

Async Model, 协作式多任务(cooperatively multi-tasked)

- 可以只运行在一个线程上，也可以把任务分布到多个线程上
- 一个异步任务只有在主动让出控制权 (yield control) 时才会被中断
    - 执行器进程本身仍然可能被操作系统调度器中断
- 异步任务非常轻量
    - 它只包含执行栈（局部变量和函数调用）以及用于恢复任务执行的必要信息（例如：当一个网络操作完成后，如何恢复）

## 何时使用Async，何时使用系统线程？

|     场景     |   使用系统线程    |        使用Async        |
|:----------:|:-----------:|:---------------------:|
| **任务运行时间** |  长时间运行的任务   |       短时间运行的任务        |
|  **任务类型**  |  CPU密集型任务   |       I/O密集型任务        |
| **并行性需求**  | 需要真正并行运行的任务 |       需要并发运行的任务       |
|  **延迟要求**  | 需要最小且可预测的延迟 | 能利用等待时间来做其他事、提升吞吐量的任务 |

## 不适合的场景

- **不适合 async 的场景：**
    - 任务会占用大量CPU，且逻辑上很长时间都不会让出控制权时
        - 否则会让整个系统的异步性能下降
- **不适合系统线程的场景：**
    - 当你为每个网络客户端都创建一个系统线程，而这些线程大多数时间都在等待I/O
        - 你会耗尽内存或线程资源
- 最好的做法是：两者结合使用，这样才能真正发挥Rust并发模型的威力

## Rust 与 Async/Await

- `NodeJS`、`Go`、`C#`、`Python`等语言都实现了一套由明确设计主张且“开箱即用”(batteries included)的 `Async/Await` 方案.
- 而`C++`和`Rust`都采用了一种更为通用(agnostic)的方式。它们提供了构建的基础模块，但将组装成框架的工作留给了你
    - 缺点：上手需要做更多的工作

## Tokio

- [Tokio 简介](./tokio_introduction)
- [系统线程 vs 绿色线程](./tokio_os_threads_vs_green_threads)