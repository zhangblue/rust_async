# 综合来看：Future、任务和线程

## 如何选择实现并发的方式

视情况而定

- 并且在很多场景中，选择并不是“线程或异步：，而是”线程加异步“
- `Async`模型提供了一种不同且最终是互补的权衡方式
    - 并发操作不需要各自的线程
    - 它们可以在任务(task)上运行
- 任务类似于线程，但不是由操作系统管理，而是由运行时(runtime)管理
- 线程是统一操作集合的边界；线程之间可以并发运行
- 而任务则是异步操作集合的边界；任务之间以及任务内部都可以并发运行，因为任务体内可以在多个`future`之间切换
- `future`是Rust并发的最小单位，每个`future`可能是其他`future`的树形结构
- 运行时(确切的说是其executor)负责管理任务，而任务则负责管理`futures`
    - 任务就像是运行时管理的轻量线程，并拥有由于不受操作系统管理而带来的额外能力
- 但这并不意味着异步任务总比线程好(反之亦然)
- 使用线程进行并发从某些方面看时更简单的编程模型
    - 线程有点像“一次性启动就运行到底”，它们没有像`future`那样的原生机制，因此线程会一直运行，除非被操作系统打断
    - 线程没有像`future`那样的任务内并发机制
- 此外，Rust中的线程也有没取消机制，尽管本章节没有明确讨论这个话题，但可以从`future`在结束时状态被正确清理的行为中看出其支持取消的能力
- 热舞让我们对`futures`拥有更多的控制权，让我们可以选择在何时、如何对`futures`分组
- 死即伤，线程和任务常常可以很好的协作，因为在某些运行时中，任务可以在不同线程之间移动
- 事实上，我们一直在使用的运行时(包括`spawn_blocking`和`spawn_task`函数)默认就是多线程的。
- 许多运行时都是用所谓的”工作窃取(work stealing)"机制，在不同线程之间透明的移动任务，以根据线程利用率优化整体性能
    - 这种机制实际上需要线程、任务和`futures`三者的配合

## 当你在思考使用哪种方式时，可以参考以下经验法则：

- 如果任务可以高度并行，比如处理一批可以分开处理的数据，那么使用线程更好
- 如果任务时高度并发的，比如处理来自多个不同来源、间隔不一的数据，那么使用`async`更合适
- 如果你即需要并行又需要并发，不必非选其一。你可以自由的将它们结合起来，让它们各自尽其所能。
    - 例如：